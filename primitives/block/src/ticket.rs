// Copyright 2019-2020 PolkaX Authors. Licensed under GPL-3.0.

use minicbor::{decode, encode, Decoder, Encoder};
use serde::{Deserialize, Serialize};

/// A Ticket is a marker of a tick of the blockchain's clock.
/// It is the source of randomness for proofs of storage and leader election.
/// It is generated by the miner of a block using a VRF and a VDF.
#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash, Serialize, Deserialize)]
pub struct Ticket {
    /// VRF proof
    #[serde(rename = "VRFProof")]
    #[serde(with = "plum_bytes")]
    pub vrf_proof: Vec<u8>,
}

impl Ticket {
    /// Create a ticket with the given VRF proof.
    pub fn new<T: Into<Vec<u8>>>(vrf_proof: T) -> Self {
        Self {
            vrf_proof: vrf_proof.into(),
        }
    }
}

// Implement CBOR serialization for Ticket.
impl encode::Encode for Ticket {
    fn encode<W: encode::Write>(&self, e: &mut Encoder<W>) -> Result<(), encode::Error<W::Error>> {
        e.array(1)?.bytes(&self.vrf_proof)?.ok()
    }
}

// Implement CBOR deserialization for Ticket.
impl<'b> decode::Decode<'b> for Ticket {
    fn decode(d: &mut Decoder<'b>) -> Result<Self, decode::Error> {
        let array_len = d.array()?;
        assert_eq!(array_len, Some(1));
        Ok(Ticket {
            vrf_proof: d.bytes()?.to_vec(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::Ticket;

    #[test]
    fn ticket_cbor_serde() {
        let cases = vec![(
            Ticket {
                vrf_proof: b"vrf proof0000000vrf proof0000000".to_vec(),
            },
            vec![
                129, 88, 32, 118, 114, 102, 32, 112, 114, 111, 111, 102, 48, 48, 48, 48, 48, 48,
                48, 118, 114, 102, 32, 112, 114, 111, 111, 102, 48, 48, 48, 48, 48, 48, 48,
            ],
        )];

        for (ticket, expected) in cases {
            let ser = minicbor::to_vec(&ticket).unwrap();
            assert_eq!(ser, expected);
            let de = minicbor::decode::<Ticket>(&ser).unwrap();
            assert_eq!(de, ticket);
        }
    }

    #[test]
    fn ticket_json_serde() {
        let cases = vec![(
            Ticket {
                vrf_proof: b"vrf proof0000000vrf proof0000000".to_vec(),
            },
            r#"{"VRFProof":"dnJmIHByb29mMDAwMDAwMHZyZiBwcm9vZjAwMDAwMDA="}"#,
        )];

        for (ticket, expected) in cases {
            let ser = serde_json::to_string(&ticket).unwrap();
            assert_eq!(ser, expected);
            let de = serde_json::from_str::<Ticket>(&ser).unwrap();
            assert_eq!(de, ticket);
        }
    }
}
