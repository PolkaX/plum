// Copyright 2019-2020 PolkaX Authors. Licensed under GPL-3.0.

use serde::{de, ser};

/// A Ticket is a marker of a tick of the blockchain's clock.
/// It is the source of randomness for proofs of storage and leader election.
/// It is generated by the miner of a block using a VRF and a VDF.
#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]
pub struct Ticket {
    /// VRF proof
    pub vrf_proof: Vec<u8>,
}

impl Ticket {
    /// Create a ticket with the given VRF proof.
    pub fn new<T: Into<Vec<u8>>>(vrf_proof: T) -> Self {
        Self {
            vrf_proof: vrf_proof.into(),
        }
    }
}

impl ser::Serialize for Ticket {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ser::Serializer,
    {
        self::cbor::serialize(self, serializer)
    }
}

impl<'de> de::Deserialize<'de> for Ticket {
    fn deserialize<D>(deserializer: D) -> Result<Ticket, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        self::cbor::deserialize(deserializer)
    }
}

/// Ticket CBOR serialization/deserialization
pub mod cbor {
    use serde::{de, ser, Deserialize, Serialize};
    use serde_bytes::{ByteBuf, Bytes};

    use super::Ticket;

    /// CBOR serialization
    pub fn serialize<S>(ticket: &Ticket, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ser::Serializer,
    {
        let value = Bytes::new(&ticket.vrf_proof);
        let value = (value,);
        value.serialize(serializer)
    }

    /// CBOR deserialization
    pub fn deserialize<'de, D>(deserializer: D) -> Result<Ticket, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        let (vrf_proof,): (ByteBuf,) = Deserialize::deserialize(deserializer)?;
        Ok(Ticket {
            vrf_proof: vrf_proof.into_vec(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::Ticket;

    #[test]
    fn ticket_cbor_serde() {
        let ticket = Ticket {
            vrf_proof: b"vrf proof0000000vrf proof0000000".to_vec(),
        };
        let expected = [
            129, 88, 32, 118, 114, 102, 32, 112, 114, 111, 111, 102, 48, 48, 48, 48, 48, 48, 48,
            118, 114, 102, 32, 112, 114, 111, 111, 102, 48, 48, 48, 48, 48, 48, 48,
        ];

        let ser = serde_cbor::to_vec(&ticket).unwrap();
        assert_eq!(ser, &expected[..]);
        let de = serde_cbor::from_slice::<Ticket>(&ser).unwrap();
        assert_eq!(de, ticket);
    }
}
