// Copyright 2019 PolkaX Authors. Licensed under GPL-3.0.

//! Keystore (and session key management) for ed25519 based chains like Polkadot.

#![warn(missing_docs)]

use crate::crypto::{key_types, KeyTypeId};
use crate::error::Error;
use address::{Account, Address, Display, Network};
use bls::Serialize;
use parking_lot::RwLock;
use rand::{rngs::OsRng, RngCore};
use secp256k1;
use std::convert::TryInto;
use std::{
    fs::{self, File},
    io::Write,
    path::PathBuf,
    sync::Arc,
};

/// Keystore pointer
pub type KeyStorePtr = Arc<RwLock<Store>>;
pub type Result<T> = std::result::Result<T, Error>;

#[derive(Clone)]
pub struct KeyPair {
    pub pubkey: Vec<u8>,
    pub privkey: Vec<u8>,
    pub key_type: KeyTypeId,
}

impl KeyPair {
    pub fn to_string(&self, key_type: KeyTypeId, net: Network) -> String {
        let addr: Address = match key_type {
            key_types::BLS => Account::BLS(self.pubkey.clone()).try_into().unwrap(),
            key_types::SECP256K1 => Account::SECP256K1(self.pubkey.clone()).try_into().unwrap(),
            _ => unreachable!("key types [bls, secp256k1]"),
        };
        format!(
            "pubkey:{}\nprivkey:{}\naddress:{}",
            hex::encode(&self.pubkey),
            hex::encode(&self.privkey),
            addr.display(net)
        )
    }

    pub fn generate_key_pair(key_type: KeyTypeId) -> Result<Self> {
        let mut key = [0u8; 16];
        let pubkey: Vec<u8>;
        let privkey: Vec<u8>;

        OsRng.fill_bytes(&mut key);
        match key_type {
            key_types::BLS => {
                let private_key = bls::PrivateKey::generate(&mut OsRng);
                let public_key = private_key.public_key();
                pubkey = public_key.as_bytes();
                privkey = private_key.as_bytes();
            }
            key_types::SECP256K1 => {
                let secert = secp256k1::SecretKey::random(&mut OsRng);
                let public_key = secp256k1::PublicKey::from_secret_key(&secert);
                pubkey = public_key.serialize().to_vec();
                privkey = secert.serialize().to_vec();
            }
            _ => return Err(Error::InvalidKeyType),
        }
        Ok(KeyPair {
            pubkey: pubkey,
            privkey: privkey,
            key_type: key_type,
        })
    }

    pub fn get_keypair_by_private(key_type: KeyTypeId, privkey: &[u8]) -> Result<Self> {
        let pubkey: Vec<u8>;
        match key_type {
            key_types::BLS => {
                let private_key = bls::PrivateKey::from_bytes(privkey)?;

                let public_key = private_key.public_key();
                pubkey = public_key.as_bytes();
            }
            key_types::SECP256K1 => {
                let secert = secp256k1::SecretKey::parse_slice(privkey)?;
                let public_key = secp256k1::PublicKey::from_secret_key(&secert);
                pubkey = public_key.serialize().to_vec();
            }
            _ => return Err(Error::InvalidKeyType),
        }
        Ok(KeyPair {
            pubkey: pubkey,
            privkey: privkey.to_vec(),
            key_type: key_type,
        })
    }
}

/// Key store.
///
/// Stores key pairs in a file system store + short lived key pairs in memory.
///
/// Every pair that is being generated by a `seed`, will be placed in memory.
#[derive(Default)]
pub struct Store {
    pub path: PathBuf,
    //password: Option<Protected<String>>,
}

impl Store {
    /// Open the store at the given path.
    ///
    /// Optionally takes a password that will be used to encrypt/decrypt the keys.
    pub fn open(&self) -> Result<KeyStorePtr> {
        fs::create_dir_all(&self.path)?;
        let path = self.path.clone();
        let instance = Self { path: path };
        Ok(Arc::new(RwLock::new(instance)))
    }

    /// Generate a new key.
    ///
    /// Places it into the file system store.
    pub fn generate_key(&self, key_type: KeyTypeId) -> Result<KeyPair> {
        let pair = KeyPair::generate_key_pair(key_type)?;
        let mut file = File::create(self.key_file_path(pair.pubkey.as_slice(), key_type))?;
        println!("{:?}", file);
        serde_json::to_writer(&file, &hex::encode(&pair.clone().privkey))?;
        file.flush()?;
        Ok(pair)
    }

    pub fn import_key(&self, key_type: KeyTypeId, privkey: &[u8]) -> Result<KeyPair> {
        let pair = KeyPair::get_keypair_by_private(key_type, privkey)?;
        let mut file = File::create(self.key_file_path(pair.pubkey.as_slice(), key_type))?;
        serde_json::to_writer(&file, &hex::encode(&pair.clone().privkey))?;
        file.flush()?;
        Ok(pair)
    }

    /// Insert a new key with anonymous crypto.
    ///
    /// Places it into the file system store.
    fn insert_unknown(&self, key_type: KeyTypeId, suri: &str, public: &[u8]) -> Result<()> {
        let mut file = File::create(self.key_file_path(public, key_type)).map_err(Error::Io)?;
        serde_json::to_writer(&file, &suri).map_err(Error::Json)?;
        file.flush().map_err(Error::Io)?;
        Ok(())
    }

    /// Returns the file path for the given public key and key type.
    fn key_file_path(&self, public: &[u8], key_type: KeyTypeId) -> PathBuf {
        let mut buf = self.path.clone();
        let key_type = hex::encode(key_type.0);
        let key = hex::encode(public);
        buf.push(key_type + key.as_str());
        buf
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::address::{Account, Display, Network};
    use std::convert::TryInto;
    use std::str::FromStr;
    use tempfile::TempDir;

    #[test]
    fn test_generate_key() {
        let st = Store {
            path: PathBuf::from_str("./tmp/").unwrap(),
        };
        let _ = st.open().unwrap();

        // Generate a key of a different type
        let keypair = st.generate_key(KeyTypeId::default()).unwrap();
        let bls_addr: crate::address::Address = crate::address::Account::BLS(keypair.pubkey)
            .try_into()
            .unwrap();
        println!("{}\n", bls_addr.display(Network::Testnet));

        let keypair = st.generate_key(key_types::SECP256K1).unwrap();
        let secp_addr: crate::address::Address = crate::address::Account::SECP256K1(keypair.pubkey)
            .try_into()
            .unwrap();
        println!("{}\n", secp_addr.display(Network::Testnet));
    }
}
